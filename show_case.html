<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PDF -> JSONL Simulation</title>
<style>
    body, html {
        height: 100%;
        margin: 0;
        background-color: black;
        overflow: hidden;
        font-family: 'Courier New', monospace;
        color: lime;
    }
    #matrix {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        padding: 20px;
        justify-content: center;
        overflow-y: auto;
        max-height: 70%;
        margin-bottom: 2%;
    }
    .bottom-text {
        max-height: 25%;
        overflow-y: auto;
    }
    .window {
        min-height: 220px;
        padding: 20px;
        background-color: rgba(0, 0, 0, 0.8);
        border: 1px solid lime;
        box-shadow: 0 0 10px lime;
        overflow: auto;
        font-size: 12px;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        opacity: 0; /* Start with windows invisible */
    }
    .window.visible {
        animation: fadeIn 1s forwards; /* Only animate to visible when added */
    }
    .window:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px lime;
    }
    h4 {
        margin: 0 0 10px 0;
        font-size: 18px;
        text-shadow: 0 0 8px lime;
    }
    .ip-address {
        font-size: 12px;
        opacity: 0.7;
    }
    @keyframes fadeIn {
        to { opacity: 1; }
    }
    @keyframes matrixBackground {
        to { background-position: 0 -10000px; }
    }
    body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(transparent, transparent 10px, rgba(0, 255, 0, 0.15) 10px, rgba(0, 255, 0, 0.15) 20px);
        animation: matrixBackground 60s linear infinite;
        pointer-events: none;
        z-index: -1;
    }
    .fullscreen-window {
        display: none; /* Initially hidden */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.95);
        color: lime;
        padding: 20px;
        box-sizing: border-box;
        font-size: 16px;
        z-index: 10; /* Ensure it's above everything else */
        overflow: auto;
        animation: fadeIn 2s forwards; /* Use the existing fadeIn animation */
    }
    h1{
        margin: 0;
        align-items: center;
    }
</style>
</head>
<body>

<div id="matrix"></div>
<div id="bottom-text" class="bottom-text"></div>
<div id="fullscreen-window" class="fullscreen-window">
    <h2>Assembler Script Simulation</h2>
    <p>Simulating the compilation of the assembler script...</p>
    <pre id="assembler-output"></pre>
</div>
<div id="final-fullscreen-window" class="fullscreen-window" style="display: none;">
    <h2>Process Simulation Complete!</h2>
    <p>Completed PDF -> Combined JSONL file in 4.8 seconds</p>
    <h1>Any Questions?</h1>
</div>

<script>
function showSimulationCompleteWindow() {
    const windowDiv = document.createElement('div');
    windowDiv.className = 'window visible';
    windowDiv.style.textAlign = 'center'; // Center the text for emphasis
    windowDiv.innerHTML = `
        <h2>Please Hold Processing...</h2>
        <p>The Process has finished executing.</p>
    `;

    // Ensures the final message is displayed after everything else
    document.getElementById('matrix').appendChild(windowDiv);
}

function simulateAssemblerScript() {
    // Extended and more complex assembler script simulation with hardware interactions
    const script = `
;   Begin Python Script process.py
        Loaded 24707.00026.pdf
        Processing 24707.00026.pdf
        Page 1/4
        Page 2/4
        Page 3/4
        Page 4/4
        Output 2407.00026_fine_tuning.json
        COMPLETED

;   Begin Python Script reformat.py
        Loaded: 2407.00026_fine_tuning.json
        Processing: 2407.00026_fine_tuning.json
        Output: reformatted_2407.00026_fine_tuning.json
        COMPLETED
`;

    // Initially, show the script
    document.getElementById('assembler-output').textContent = script;

    // Simulate compilation and hardware interaction process
    setTimeout(() => {
        const compilationResult = `
; Script has compiled successfully!

;   Begin Python Script json2jsonl.py
        Loaded: reformatted_2407.00026_fine_tuning.json
        Processing: reformatted_2407.00026_fine_tuning.json
        Output: reformatted_2407.00026_fine_tuning.jsonl
        COMPLETE

;   Begin Python Script accumulate_all_jsonl_files_into_one.py
        Loaded Folder JSONL
        Processing In Progress
        reformatted_2407.00026_fine_tuning.jsonl
        reformatted_2407.00057_fine_tuning.jsonl
        reformatted_2407.02622_fine_tuning.jsonl
        Output: combined_data.jsonl
        COMPLETE
`;

        // Update the assembler output with the compilation and interaction results
        document.getElementById('assembler-output').textContent += compilationResult;

        // Visually simulate hardware interactions on the webpage
        simulateHardwareInteractions();

        // Call to show the final window, with a delay to ensure it's the last thing shown
        setTimeout(showSimulationCompleteWindow, 3000); // Show "Simulation Complete" after showing results
    }, 3000);
}

function simulateHardwareInteractions() {
    // Create elements to visually represent the hardware interactions
    const lightsIndicator = document.createElement('div');
    lightsIndicator.innerHTML = 'User Input: How is OpenQQantify processing PDFs?';
    
    const motorIndicator = document.createElement('div');
    motorIndicator.innerHTML = 'User Input: How is OpenQQantify reformatting JSON files?';
    
    const sensorIndicator = document.createElement('div');
    sensorIndicator.innerHTML = 'User Input: How is OpenQQantify converting JSON files into JSONL files?';

    // Add a container for these indicators
    const bottomText = document.createElement('div');
    bottomText.id = 'bottom-text';
    bottomText.appendChild(lightsIndicator);
    bottomText.appendChild(motorIndicator);
    bottomText.appendChild(sensorIndicator);
    document.body.appendChild(bottomText);

    // Additional visual effects for engagement
    document.body.style.backgroundColor = "black"; // Set initial background color

    // Create a container for hardware interactions
    const hardwareContainer = document.createElement('div');
    hardwareContainer.id = 'hardware-interactions';
    document.body.appendChild(hardwareContainer);

    // Light (LED) Status
    const ledStatus = document.createElement('p');
    ledStatus.innerHTML = 'We are running a script called process.py to convert the PDF files into JSON files';
    hardwareContainer.appendChild(ledStatus);

    // Motor Status
    const motorStatus = document.createElement('p');
    motorStatus.innerHTML = 'We are running a script called reformatt.py to convert the PDF files into reformatted JSON files for readability';
    hardwareContainer.appendChild(motorStatus);

    // Clock Speed Setting
    const clockSpeed = document.createElement('p');
    clockSpeed.innerHTML = 'We are running a script called json2jsonl.py to convert the JSON files into JSONL files.';
    hardwareContainer.appendChild(clockSpeed);

    // Optionally, add styles to ensure visibility
    document.getElementById('hardware-interactions');
    document.getElementById('bottom-text');
    document.getElementById('bottom-text');
}

// Assuming showSimulationCompleteWindow is defined elsewhere to handle final message display

// Call this function at the appropriate place in your script, possibly after creating server and data windows
simulateAssemblerScript();

const generateIPAddress = () => `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;


const serverRoles = [
  {
    name: "Processing PDF Files...",
    process: "Processing PDF Files...",
    execute: () => {
      // Simulate generating data
      console.log("Prcoessing data...");
      const data = Array.from({ length: 10 }, () => Math.floor(Math.random() * 100));
      console.log("Generated data:", data);
      return data;
    }
  },
  {
    name: "Reformatting JSON Files...",
    process: "Reformatting JSON...",
    execute: (data) => {
      // Simulate processing data (e.g., sorting)
      console.log("Reformatting data...");
      const processedData = data.sort((a, b) => a - b);
      console.log("Reformatted data:", processedData);
      return processedData;
    }
  },
  {
    name: "Converting JSON to JSONL...",
    process: "Converting JSON to JSONL...",
    execute: (data) => {
      // Simulate cleaning data (e.g., removing duplicates)
      console.log("Converting data...");
      const cleanedData = [...new Set(data)];
      console.log("Converted data:", cleanedData);
      return cleanedData;
    }
  },
  {
    name: "Combining JSONL Files...",
    process: "Combining JSONL FIles...",
    execute: (data) => {
      // Simulate reiterating over data (e.g., doubling values)
      console.log("Combining data...");
      const reiteratedData = data.map((item) => item * 2);
      console.log("Combined data:", reiteratedData);
      return reiteratedData;
    }
  },
  {
    name: "SHOUTOUT TO OpenQQ INTERNS",
    process: "Outputting Data...",
    execute: (data) => {
      // Simulate outputting data
      console.log("Outputting data:", data);
      // This could involve sending data to a file, database, or external system
    }
  }
];

// Example of running the simulated server roles in sequence
const data = serverRoles[0].execute();
const processedData = serverRoles[1].execute(data);
const cleanedData = serverRoles[2].execute(processedData);
const reiteratedData = serverRoles[3].execute(cleanedData);
serverRoles[4].execute(reiteratedData);

const windowData = [
    { 
        title: "Processed PDF Files",
        content: () => "JSON Files Outputted:\n\nTo simulate the Zeeman effect using RISC-V, one can implement a computational model that calculates the energy levels of atomic states in a magnetic field. This involves using the appropriate Hamiltonian and applying perturbation theory. The modularity of RISC-V allows custom instructions for matrix operations that represent the energy state transitions, and the SIMD capabilities can be leveraged to simultaneously compute energy shifts for multiple atoms or spins."
    },
    {
        title: "Reformating JSON Files",
        content: () => "Reformatting Complete:\n\nTo simulate the Zeeman effect using RISC-V, one can implement a computational model that calculates the energy levels of atomic states in a magnetic field. This involves using the appropriate Hamiltonian and applying perturbation theory. The modularity of RISC-V allows custom instructions for matrix operations that represent the energy state transitions, and the SIMD capabilities can be leveraged to simultaneously compute energy shifts for multiple atoms or spins."
    },
    {
        title: "Converted JSON To JSONL",
        content: () => "COMPLETED"
    },
    {
        title: "Combined JSONL Files",
        content: () => "COMPLETED",
    },
    {
        title: "Upload JSONL Files for Processing",
        content: () => "COMPLETED",
    },
    {
        title: "Thank For Stopping By",
        content: () => ""
    },
];

// Example function to dynamically create and update content boxes
function createAndUpdateBoxes() {
    windowData.forEach((data, index) => {
        const serverBox = document.getElementById(`server-box-${index}`);
        const dataDiv = document.createElement('div');
        dataDiv.innerHTML = `<h4>${data.title}</h4><p>${data.content()}</p>`;
        serverBox.appendChild(dataDiv);
    });
}

// Call this function to initialize the boxes after the document has loaded
document.addEventListener('DOMContentLoaded', createAndUpdateBoxes);
function createServerWindows() {
    serverRoles.forEach((server, index) => {
        setTimeout(() => {
            const ip = generateIPAddress(); // Dynamically generate IP address
            const windowDiv = document.createElement('div');
            windowDiv.className = 'window visible';
            windowDiv.innerHTML = `<h4>${server.name}</h4><div class="ip-address">${ip}</div><p>${server.process}</p>`;
            document.getElementById('matrix').appendChild(windowDiv); // Insert at the start
        }, index * 1000); // Stagger the server windows appearance
    });
}

function createDataWindows() {
    windowData.forEach((data, index) => {
        setTimeout(() => {
            const windowDiv = document.createElement('div');
            windowDiv.className = 'window visible';
            windowDiv.innerHTML = `<h4>${data.title}</h4><p id="content-${index}" style="white-space: pre-line;">${data.content()}</p>`;
            document.getElementById('matrix').appendChild(windowDiv); // Append at the end
        }, (serverRoles.length * 500) + (index * 1000)); // Ensure data windows appear after server windows
    });
}

function showFinalSimulationCompleteWindow() {
    // This function displays the very last full-screen window with the final message
    const finalWindow = document.getElementById('final-fullscreen-window');
    finalWindow.style.display = 'block';
    finalWindow.style.zIndex = 20; // Ensure it covers everything else
}

function revealFinalSimulation() {
    const allWindows = document.querySelectorAll('.window');
    const lastWindowDelay = (allWindows.length * 500) + 5000 + 15000; // Consider the time for all windows plus assembler simulation and compilation result

    setTimeout(() => {
        document.getElementById('fullscreen-window').style.display = 'block';
        simulateAssemblerScript();

        // After the assembler script simulation, show the final simulation complete window
        setTimeout(showFinalSimulationCompleteWindow, 8000); // Adjust this time based on the length of your assembler simulation
    }, lastWindowDelay);
}

// Ensure server windows and data windows are created first
createServerWindows();
setTimeout(createDataWindows, serverRoles.length * 500);
revealFinalSimulation(); // Modified to include the final simulation complete window
// Set a timeout to redirect after showing the final results for 5 seconds

//This is the method that is bringing the computer to the drive page after the transitions play out. Keep this in case Paul has any files that can work with it.
// setTimeout(function() {
//     window.location.href = "/"; // Redirect to the Flask route serving mainpage.html
// }, 35000); // Adjust delay as per requirement

</script>


